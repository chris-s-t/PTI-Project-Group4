<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
        body {
          background: #000;
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          margin: 0;
        }
    
        canvas {
          image-rendering: pixelated;
          image-rendering: crisp-edges;
          border: 2px solid white;
        }
      </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="736"></canvas>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
    
        const zoom = 2;
    
        const playerImg = new Image()
        playerImg.src = 'Assets/Characters/MiniPrincess.png'
    
        const mapImg = new Image();
        mapImg.src = 'map2.jpg';
    
        const player = {
          x: 290,
          y: 70,
          width: 32,     // adjust based on your sprite frame width
          height: 32,    // adjust based on your sprite frame height
          frameX: 0,
          frameY: 0,     // use this for direction-based row selection
          maxFrame: 3,   // number of animation frames per row - adjust as needed
          frameDelay: 10,
          frameTimer: 0,
          hitbox: {
            offsetX: 6,
            offsetY: 15,
            width: 18,
            height: 20,
          },
        };
        const hitbox = {
          x: player.x + player.hitbox.offsetX,
          y: player.y + player.hitbox.offsetY,
          width: player.hitbox.width,
          height: player.hitbox.height
        };
    
        const camera = {
          x: 0,
          y: 0,
          update: () => {
            const mapWidth = mapGrid[0].length * tileWidth;
            const mapHeight = mapGrid.length * tileHeight;
    
            let targetX = player.x + player.width / 2 - canvas.width / (2 * zoom);
            let targetY = player.y + player.height / 2 - canvas.height / (2 * zoom);
    
            targetX = Math.max(0, Math.min(targetX, mapWidth - canvas.width / zoom));
            targetY = Math.max(0, Math.min(targetY, mapHeight - canvas.height / zoom));
    
            camera.x = targetX;
            camera.y = targetY;
          },
        };
        const mapGrid = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],            
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],            
            [1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],           
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],            
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]        
        ];
    
        const tileWidth = 20;
        const tileHeight = 20;
        const startX = 20; // adjust these to match your map
        const startY = 45;
        let facingLeft = false;
        let isIdle = true;
    
        const collisions = [];
    
        for (let row = 0; row < mapGrid.length; row++) {
          for (let col = 0; col < mapGrid[row].length; col++) {
            if (mapGrid[row][col] === 1) {
              collisions.push({
                x: startX + col * tileWidth,
                y: startY + row * tileHeight,
                width: tileWidth,
                height: tileHeight
              });
            } else if (mapGrid[row][col] === 2) {
              collisions.push({
                x: startX + col * tileWidth - 10,
                y: startY + row * tileHeight,
                width: tileWidth,
                height: tileHeight
              });
            }
          }
        }
        // Collision detection
        function isColliding(a, b) {
          return a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y;
        }
    
        document.addEventListener("keydown", function (e) {
          const lastX = player.x;
          const lastY = player.y;
          const speed = 2;
    
          let moved = false;
    
          if (e.key === "ArrowUp") {
            player.y -= speed;
            player.frameY = 1;
            moved = true;
          }
          if (e.key === "ArrowDown") {
            player.y += speed;
            player.frameY = 1;
            moved = true;
          }
          if (e.key === "ArrowLeft") {
            player.x -= speed;
            player.frameY = 1;
            moved = true;
            facingLeft = true;
          }
          if (e.key === "ArrowRight") {
            player.x += speed;
            player.frameY = 1;
            moved = true;
            facingLeft = false;
          }
    
          hitbox.x = player.x + player.hitbox.offsetX;
          hitbox.y = player.y + player.hitbox.offsetY;
    
          // Check for collision and revert if needed
          for (let collision of collisions) {
            if (isColliding(hitbox, collision)) {
              player.x = lastX;
              player.y = lastY;
              hitbox.x = lastX + player.hitbox.offsetX;
              hitbox.y = lastY + player.hitbox.offsetY;
              moved = false;
              break;
            }
          }
    
          if (moved) {
            player.frameTimer++;
            if (player.frameTimer >= player.frameDelay) {
              player.frameX = (player.frameX + 1) % (player.maxFrame + 1);
              player.frameTimer = 0;
            }
          } else {
            player.frameX = 0;
          }
    
          camera.update();
        });
        function drawPlayer() {
            const drawX = (player.x - player.hitbox.offsetX - camera.x) * zoom;
            const drawY = (player.y - player.hitbox.offsetY - camera.y) * zoom;
          const scaleFactor = 4;
          const drawWidth = player.width * scaleFactor;
          const drawHeight = player.height * scaleFactor;
          ctx.save(); // Save current canvas state
    
          if (facingLeft) {
            ctx.translate(drawX + drawWidth, drawY); // Move to the player's position
            ctx.scale(-1, 1); // Flip horizontally
            ctx.drawImage(
              playerImg,
              player.frameX * player.width,
              player.frameY * player.height,
              player.width,
              player.height,
              0, 0,
              drawWidth,
              drawHeight
            );
          } 
          else {
            ctx.translate(drawX, drawY);
            ctx.drawImage(
              playerImg,
              player.frameX * player.width,
              player.frameY * player.height,
              player.width,
              player.height,
              0, 0,
              drawWidth,
              drawHeight
            );
          }
    
          ctx.restore(); // Restore canvas state
        }
        function drawMap() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.scale(zoom, zoom);
          ctx.translate(-camera.x, -camera.y);
    
          ctx.drawImage(mapImg, 0, 0);
    
          for (let box of collisions) {
            ctx.strokeStyle = 'red';
            ctx.strokeRect(box.x, box.y, box.width, box.height);
          }
          ctx.restore();
        }
        function gameLoop() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          camera.update();
          drawMap();
          drawPlayer();
          requestAnimationFrame(gameLoop);
        }
        mapImg.onload = () => {
          gameLoop();
        };
      </script>
</body>
</html>
